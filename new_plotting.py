"""


Contains:

    
Author: Bryce Dixon
Version: 02.08.2023    
"""

import matplotlib
from matplotlib.colors import Normalize
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import numpy as np
import scipy.interpolate
import auxiliary as aux
import matplotlib.ticker as plticker
import GP_Likelihood as gp
from MCMC_aux import get_model

poster=False


###### allows me not to show plots
matplotlib.use('Agg')
plt.rcParams.update({'font.size': 18})

def offset_subtract(rv, flags, offsets):
    """Function to return the RVs with offsets subtracted

    Parameters
    ----------
    rv: array of floats
        y-axis array of the RVs
    flags: array of floats
        array of flags representing offsets generated by the combine_data function
    offsets: list or tuple of floats
        list or tuple of offsets ordered accordingly to the inputs in the combine_data function
    
    Returns
    -------
    y: array of floats
        array of RVs with offsets subtracted
    """
    
    y_off = []
    for i in range(len(flags)):
        if flags[i] == 0.:
                y_off.append(0.)
        else:
            for a in range(len(offsets)):
                off = a+1.
                if flags[i] == off:
                    y_off.append(offsets[a])
    y = rv - y_off
    return y


# data plot function


def data_plot(time, rv, xlabel = "time [BJD]", ylabel = "RV [m/s]", y_err = None, flags = None, offsets = None, save_folder = None, savefilename = None):
    """_summary_

    Parameters
    ----------
    time: array of floats
        x-axis array of the observation times
    rv: array of floats
        y-axis array of the RVs
    xlabel: string, optional
        label of x-axis, defaults to "time [BJD]"
    ylabel: string, optional
        label of y-axis, defaults to "RV [m/s]"
    y_err: array of floats, optional
        array of rv errors, defaults to None
    flags: array of floats, optional
        array of flags representing offsets generated by the combine_data function, defaults to None
    offsets: list or tuple of floats, optional
        list or tuple of offsets ordered accordingly to the inputs in the combine_data function, defaults to None
    save_folder: string, optional
        folder to save the plot, defaults to None
    savefilename: string, optional
        name of the save file, defaults to None
  
    """
    
    fig = plt.figure(figsize = (10,7))
    ax = fig.add_subplot(1,1,1)
    
    if offsets is None and flags is None:
        ax.errorbar(time, rv, yerr = y_err, fmt = '.', color = 'k')
        ax.set_xlabel(xlabel)
        ax.set_ylabel(ylabel)
    elif offsets is None and flags is not None:
        raise KeyError("offsets must be provided when flags are given")
    elif offsets is not None and flags is None:
        raise KeyError("flags must be provided if offsets are given")
    else:
        y = offset_subtract(rv, flags, offsets)
        ax.errorbar(time, y, yerr = y_err, fmt = '.', color = 'k')
        ax.set_xlabel(xlabel)
        ax.set_ylabel(ylabel) 
    
    if save_folder is not None:
        assert savefilename is not None, "You need to give both save_folder and savefilename to save the figure"
        plt.savefig(str(save_folder)+"/"+str(savefilename)+".png", bbox_inches='tight')
        if poster:
            plt.savefig(str(save_folder)+"/"+str(savefilename)+".pdf", bbox_inches='tight')

    if savefilename is not None and save_folder is None:
        print("Figure not saved, you need to provide savefilename and save_folder both")          
            
    
    plt.show()



# gp plot funciton


import scipy.interpolate as interp

def GP_plot(time, rv, hparam, kernel_name, rv_err = None, model_list = None, model_param = None, flags = None, residuals=False, xlabel='Time [BJD]', ylabel='RV [m/s]', save_folder=None, savefilename=None):
    """

    Parameters
    ----------
    time: array of floats
        x-axis array of the observation times
    rv: array of floats
        y-axis array of the RVs
    hparam:
    kernel_name:
    rv_err: array of floats, optional
        array of rv errors, defaults to None
    model_list:
    model_param:
    flags: array of floats, optional
        array of flags representing offsets generated by the combine_data function, defaults to None
    residuals:
    xlabel:
    ylabel:
    save_folder:
    savefilename:
    """
    
    xpred = np.linspace(time[0]-1, time[-1]+1, 10000)
    
    if model_list is None and model_param is None:
        assert flags == None, "flags should not be provided if no model is in use"
        assert residuals ==  False, "residuals cannot be provided when using no model"
        loglik = gp.GPLikelihood(time, rv, rv_err, hparam, kernel_name)
        GP_y, GP_err = loglik.predict(xpred)
        
        fig = plt.figure(figsize = (10,7))
        ax = fig.add_subplot(1,1,1)
        
        ax.errorbar(time, rv, yerr = rv_err, fmt = '.', color = 'k')
        ax.plot(xpred, GP_y, linestyle = '--', color = 'orange')
        ax.fill_between(xpred, GP_y+GP_err, GP_y-GP_err, alpha=0.5, color='gray')
        ax.set_xlabel(xlabel)
        ax.set_ylabel(ylabel)
    
    elif model_list is None and model_param is not None:
        raise KeyError("model_list must be provided alongside model_param if a model is in use")
    elif model_list is not None and model_param is None:
        raise KeyError("model_param must be provided alongside model_list if a model is in use")
    
    else:
        
        if flags is None:
            model_y = get_model(model_list, time, model_param, to_ecc=False)
            loglik = gp.GPLikelihood(time, rv, rv_err, hparam, kernel_name, model_y, model_param)
            GP_y, GP_err = loglik.predict(xpred)
            smooth_model_y = get_model(model_list, xpred, model_param, to_ecc=False)
            
        if flags is not None:
            offsets = []
            try:
                off = model_param['offset'].value
                offsets.append(off)
            except:
                for i in range(len(model_list)):
                    try:
                        off = model_param['offset_'+str(i)].value
                        offsets.append(off)
                    except:
                        continue
                    
            rv = offset_subtract(rv, flags, offsets)
            
            zeros_flags = np.zeros_like(xpred)
            smooth_time = np.concatenate((time, xpred))
            smooth_flags = np.concatenate((flags, zeros_flags))
            smooth_time, smooth_flags = zip(*sorted(zip(smooth_time, smooth_flags)))
            xpred = np.array(smooth_time)
            
            model_y = get_model(model_list, time, model_param, to_ecc=False, flags = flags)
            loglik = gp.GPLikelihood(time, rv, rv_err, hparam, kernel_name, model_y, model_param)
            GP_y, GP_err = loglik.predict(xpred)
            
            smooth_model_y = get_model(model_list, xpred, model_param, to_ecc=False, flags = smooth_flags)
            
            smooth_model_y = offset_subtract(smooth_model_y, smooth_flags, offsets)
        
        if residuals is False:
            fig = plt.figure(figsize = (10,7))
            ax = fig.add_subplot(1,1,1)
            
            ax.errorbar(time, rv, yerr = rv_err, fmt = '.', color = 'k', label = 'Data')
            ax.plot(xpred, GP_y, linestyle = '--', color = 'orange', label = 'Predicted GP')
            ax.fill_between(xpred, GP_y+GP_err, GP_y-GP_err, alpha=0.5, color='gray')
            ax.plot(xpred, smooth_model_y, color = 'blue', label = 'Predicted Model')
            ax.set_xlabel(xlabel)
            ax.set_ylabel(ylabel)
        if residuals is True:
            fig, axs = plt.subplots(ncols=1, nrows=2, sharex=True, figsize=(11,5), gridspec_kw={'height_ratios': [3,1]})
            fig.subplots_adjust(hspace=0)
        
            axs[0].scatter(time_obs, y_obs-model_y, color='purple', label='Data - Model')
            axs[0].plot(pred_time, pred_y, label='Predicted GP', color='orange')
            axs[0].fill_between(pred_time, pred_y+pred_err, pred_y-pred_err, alpha=0.5, color='orange')
            axs[0].set_ylabel(ylabel)
            axs[0].legend()
        
            f = interp.interp1d(pred_time, pred_y, kind='cubic', bounds_error=False)
            new_pred_y = f(time_obs)
            res = ((y_obs-model_y)-new_pred_y)#/rv_err[0]
        
            axs[1].scatter(time_obs, res, c='purple')
            axs[1].set_ylabel("Residuals")
            axs[1].set_xlabel(xlabel)
            
    
    plt.show()
        
        