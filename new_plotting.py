"""


Contains:

    
Author: Bryce Dixon
Version: 02.08.2023    
"""

import matplotlib
from matplotlib.colors import Normalize
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import numpy as np
import scipy.interpolate
import auxiliary as aux
import matplotlib.ticker as plticker
import GP_Likelihood as gp
from MCMC_aux import get_model

poster=False


###### allows me not to show plots
matplotlib.use('Agg')
plt.rcParams.update({'font.size': 10})

def offset_subtract(rv, flags, offsets):
    """Function to return the RVs with offsets subtracted

    Parameters
    ----------
    rv: array of floats
        y-axis array of the RVs
    flags: array of floats
        array of flags representing offsets generated by the combine_data function
    offsets: list or tuple of floats
        list or tuple of offsets ordered accordingly to the inputs in the combine_data function
    
    Returns
    -------
    y: array of floats
        array of RVs with offsets subtracted
    """
    
    y_off = []
    for i in range(len(flags)):
        if flags[i] == 0.:
                y_off.append(0.)
        else:
            for a in range(len(offsets)):
                off = a+1.
                if flags[i] == off:
                    y_off.append(offsets[a])
    y = rv - y_off
    return y


# data plot function


def data_plot(time, rv, xlabel = "time [BJD]", ylabel = "RV [m/s]", legend = True, y_err = None, flags = None, offsets = None, save_folder = None, savefilename = None):
    """_summary_

    Parameters
    ----------
    time: array of floats
        x-axis array of the observation times
    rv: array of floats
        y-axis array of the RVs
    xlabel: string, optional
        label of x-axis, defaults to "time [BJD]"
    ylabel: string, optional
        label of y-axis, defaults to "RV [m/s]"
    legend: bool, optional
        enable the plotting of a legend, defaults to True
    y_err: array of floats, optional
        array of rv errors, defaults to None
    flags: array of floats, optional
        array of flags representing offsets generated by the combine_data function, defaults to None
    offsets: list or tuple of floats, optional
        list or tuple of offsets ordered accordingly to the inputs in the combine_data function, defaults to None
    save_folder: string, optional
        folder to save the plot, defaults to None
    savefilename: string, optional
        name of the save file, defaults to None
  
    Returns
    -------
    rv plot with any offsets subtracted from the data
    """
    
    # set up the figure
    fig = plt.figure(figsize = (10,7))
    ax = fig.add_subplot(1,1,1)
    
    # simple plot for no offsets
    if offsets is None and flags is None:
        ax.errorbar(time, rv, yerr = y_err, fmt = '.', color = 'darkgreen')
        ax.set_xlabel(xlabel)
        ax.set_ylabel(ylabel)
    elif offsets is None and flags is not None:
        raise KeyError("offsets must be provided when flags are given")
    elif offsets is not None and flags is None:
        raise KeyError("flags must be provided if offsets are given")
    else:
        # offset subtract function to get subtracted y
        y = offset_subtract(rv, flags, offsets)
        # set up list of colours for points, currently can support 6 datasets
        c_list = ['darkgreen', 'darkred', 'magenta', 'cyan', 'gold', 'saddlebrown']
        c_dict = {'darkgreen':'Dataset_1', 'darkred':'Dataset_2', 'magenta':'Dataset_3', 'cyan':'Dataset_4', 'gold':'Dataset_5', 'saddlebrown':'Dataset_6'}
        c_array = []
        for i in range(len(flags)):
            for a in range(len(c_list)):
                if flags[i] == a:
                    c_array.append(c_list[a])
        # c_array is an array in the same form as the flags but where numbers are replaced by colours
        c_array = np.array(c_array)
        rv_err = np.array(y_err)
        for g in np.unique(c_array):
            # plot the data in different colours and labeled depending on its offset
            ix = np.where(c_array == g)
            ax.errorbar(time[ix], y[ix], yerr = rv_err[ix], fmt = '.', c = g, label = c_dict[g])
        ax.set_xlabel(xlabel, fontsize = 10)
        ax.set_ylabel(ylabel, fontsize = 10)
        if legend is True:
            ax.legend(bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0, fontsize = 10) 
    
    if save_folder is not None:
        assert savefilename is not None, "You need to give both save_folder and savefilename to save the figure"
        plt.savefig(str(save_folder)+"/"+str(savefilename)+".png", bbox_inches='tight')
        if poster:
            plt.savefig(str(save_folder)+"/"+str(savefilename)+".pdf", bbox_inches='tight')

    if savefilename is not None and save_folder is None:
        print("Figure not saved, you need to provide savefilename and save_folder both")          
            
    
    plt.show()



# gp plot funciton


import scipy.interpolate as interp

def GP_plot(time, rv, hparam, kernel_name, rv_err = None, model_list = None, model_param = None, flags = None, xpred = None, residuals=False, xlabel='Time [BJD]', ylabel='RV [m/s]', legend = True, save_folder=None, savefilename=None):
    """

    Parameters
    ----------
    time: array of floats
        x-axis array of the observation times
    rv: array of floats
        y-axis array of the RVs
    hparam: dictionary
        dictionary of the hyperparameters
    kernel_name: string
        name of the kernel
    rv_err: array of floats, optional
        array of rv errors, defaults to None
    model_list: list of strings
        list of the models in use
    model_param: dictionary
        dictionary of model parameters
    flags: array of floats, optional
        array of flags representing offsets generated by the combine_data function, defaults to None
    xpred: array of floats, optional
        array of prediced times to be used for the smooth model, defaults to intervals of 0.1 between the max and min times
    residuals: bool, optional
        enable the plotting of residuals, defaults to false
    xlabel: string, optional
        label of x-axis, defaults to "time [BJD]"
    ylabel: string, optional
        label of y-axis, defaults to "RV [m/s]"
    legend: bool, optional
        enable the plotting of a legend, defaults to True
    save_folder: string, optional
        folder to save the plot, defaults to None
    savefilename: string, optional
        name of the save file, defaults to None
    
    Returns
    -------
    rv plot with the predicted GP and any offsets subtracted from the data along with any models and residuals
    """
    
    # generate a predicted x array for the smooth models if none is given
    if xpred is None:
        xpred = np.arange(time[0]-1, time[-1]+1, 0.1)
    
    if model_list is None and model_param is None:
        # if no model is in use there should be no flags and residuals
        assert flags == None, "flags should not be provided if no model is in use"
        assert residuals ==  False, "residuals cannot be provided when using no model"
        # calculate GP_y for no model
        loglik = gp.GPLikelihood(time, rv, rv_err, hparam, kernel_name)
        GP_y, GP_err = loglik.predict(xpred)
        
        fig = plt.figure(figsize = (10,7))
        ax = fig.add_subplot(1,1,1)
        
        # plots for no model
        ax.errorbar(time, rv, yerr = rv_err, fmt = '.', color = 'darkgreen', label = 'Data')
        ax.plot(xpred, GP_y, linestyle = '--', color = 'orange', label = 'Predicted GP')
        ax.fill_between(xpred, GP_y+GP_err, GP_y-GP_err, alpha=0.5, color='gray')
        ax.set_xlabel(xlabel)
        ax.set_ylabel(ylabel)
        if legend is True:
            ax.legend(bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0, fontsize = 10)
    
    # check inputs are correct
    elif model_list is None and model_param is not None:
        raise KeyError("model_list must be provided alongside model_param if a model is in use")
    elif model_list is not None and model_param is None:
        raise KeyError("model_param must be provided alongside model_list if a model is in use")
    
    else:
        # if a model is in use
        if flags is None:
            # no flags suggests no offsets are in use, check if this is the case
            for i in model_list:
                if i.startswith('off') or i.startswith('Off'):
                    raise KeyError("flags must be provided if using offsets")
            # ganerate model and GP_y for no offsets
            model_y = get_model(model_list, time, model_param, to_ecc=False)
            loglik = gp.GPLikelihood(time, rv, rv_err, hparam, kernel_name, model_y, model_param)
            GP_y, GP_err = loglik.predict(xpred)
            # smooth model generated based on xpred
            smooth_model_y = get_model(model_list, xpred, model_param, to_ecc=False)
            # GP_y + smooth_model_y will be plotted
            gp_mod_y = smooth_model_y + GP_y
            
        if flags is not None:
            # flags suggests an offset model is in use, check if this is the case
            if 'offset' in model_list:
                pass
            elif 'Offset' in model_list:
                pass
            else:
                raise KeyError("offsets should be provided if flags are given")
            # GP_y can be generated from the model_y before it is adjusted for offsets
            model_y = get_model(model_list, time, model_param, to_ecc=False, flags = flags)
            loglik = gp.GPLikelihood(time, rv, rv_err, hparam, kernel_name, model_y, model_param)
            GP_y, GP_err = loglik.predict(xpred)
            
            # put the offset values in a list to be entered into the offset_subtract function
            offsets = []
            try:
                off = model_param['offset'].value
                offsets.append(off)
            except:
                for i in range(len(model_list)):
                    try:
                        off = model_param['offset_'+str(i)].value
                        offsets.append(off)
                    except:
                        continue
            
            # obtain the offset subtracted rv data        
            rv = offset_subtract(rv, flags, offsets)
            
            # create a new model list without offsets to be used in the new model y
            new_model_list = []
            for i in model_list:
                if i.startswith('off') or i.startswith('Off'):
                    continue
                else:
                    new_model_list.append(i)
            
            # remove offsets from the model parameters so they can be used with the new model y
            mod_key = list(model_param.keys())
            for i in mod_key:
                if i.startswith('off'):
                    del model_param[i]
            
            # smooth_model_y is generated from the offset subtracted data so there is no need to have offsets in the model parameters or model list any more
            smooth_model_y = get_model(new_model_list, xpred, model_param, to_ecc=False)
            gp_mod_y = smooth_model_y + GP_y
            
            # set up the list of colours for points, currently can support 6 datasets
            c_list = ['darkgreen', 'darkred', 'magenta', 'cyan', 'gold', 'saddlebrown']
            c_dict = {'darkgreen':'Dataset_1', 'darkred':'Dataset_2', 'magenta':'Dataset_3', 'cyan':'Dataset_4', 'gold':'Dataset_5', 'saddlebrown':'Dataset_6'}
            c_array = []
            for i in range(len(flags)):
                for a in range(len(c_list)):
                    if flags[i] == a:
                        c_array.append(c_list[a])
            # c_array is an array in the same form as the flags but where numbers are replaced by colours
            c_array = np.array(c_array)
        
        if residuals is False:
            # set up one plot for no residuals
            fig = plt.figure(figsize = (10,7))
            ax = fig.add_subplot(1,1,1)
            
            try:
                # try plotting multiple colours for if offsets are present
                rv_err = np.array(rv_err)
                for g in np.unique(c_array):
                    ix = np.where(c_array == g)
                    ax.errorbar(time[ix], rv[ix], yerr = rv_err[ix], fmt = '.', c = g, label = c_dict[g])
            except:
                # plot data if no offsets are present
                ax.errorbar(time, rv, yerr = rv_err, fmt = '.', color = 'darkgreen', label = 'Data')
            
            # plots for predicted GP and model+GP
            ax.plot(xpred, GP_y, linestyle = '--', color = 'orange', label = 'Predicted GP')
            ax.fill_between(xpred, gp_mod_y+GP_err, gp_mod_y-GP_err, alpha=0.5, color='gray')
            ax.plot(xpred, gp_mod_y, color = 'blue', label = 'Predicted Model+GP')
            ax.set_xlabel(xlabel)
            ax.set_ylabel(ylabel)
            if legend is True:
                ax.legend(bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0, fontsize = 10)
        
        if residuals is True:
            # set up two plots for residuals
            fig, axs = plt.subplots(ncols=1, nrows=2, sharex=True, figsize=(10,7), gridspec_kw={'height_ratios': [3,1]})
            fig.subplots_adjust(hspace=0)
            
            try:
                # try plotting multiple colours for if offsets are present
                rv_err = np.array(rv_err)
                for g in np.unique(c_array):
                    ix = np.where(c_array == g)
                    axs[0].errorbar(time[ix], rv[ix], yerr = rv_err[ix], fmt = '.', c = g, label = c_dict[g])
            except:
                # plot data if no offsets are present
                axs[0].errorbar(time, rv, yerr = rv_err, fmt = '.', color = 'darkgreen', label = 'Data')
            
            # plots for predicted GP and model+GP on the first plot
            axs[0].plot(xpred, GP_y, linestyle = '--', color = 'orange', label = 'Predicted GP')
            axs[0].plot(xpred, gp_mod_y, color = 'blue', label = 'Predicted Model+GP')
            axs[0].fill_between(xpred, gp_mod_y+GP_err, gp_mod_y-GP_err, alpha=0.5, color='gray')
            axs[0].tick_params(axis='y', labelsize=10)
            axs[0].set_ylabel(ylabel, size = 10)
            if legend is True:
                axs[0].legend(bbox_to_anchor=(1.02, 1), loc='upper left', borderaxespad=0, fontsize = 10)

            # interpolate the smooth GP+model to get the points relating to the time array
            f = interp.interp1d(xpred, gp_mod_y, kind='cubic', bounds_error=False)
            new_pred_y = f(time)
            # subtract the points relating to the time array from the rv data to get residuals
            res = (rv-new_pred_y)

            try:
                # try plotting multiple colours for offsets on the second plot
                axs[1].scatter(time, res, c = c_array, s = 10)
            except:
                # plotting for no offsets on the second plot
                axs[1].scatter(time, res, c='darkgreen', s = 10)
            axs[1].set_ylabel("Residuals", size = 10)
            axs[1].set_xlabel(xlabel, size = 10)
            axs[1].tick_params(axis='y', labelsize=10)
            axs[1].tick_params(axis='x', labelsize=10)
        
    if save_folder is not None:
        assert savefilename is not None, "You need to give both save_folder and savefilename to save the figure"
        plt.savefig(str(save_folder)+"/"+str(savefilename)+".png", bbox_inches='tight')

    if savefilename is not None and save_folder is None:
        print("Figure not saved, you need to provide savefilename and save_folder both")
            
            
    
    plt.show()
        
        